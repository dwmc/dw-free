#!/usr/bin/perl
# yes, there are so many better testing modules than just doing this in a crappy
# half-ass way.

use strict;
use lib "$ENV{LJHOME}/cgi-bin";
require 'ljlib.pl';

use Data::Dumper;

# much time passes ...
my $u1 = LJ::load_user( 'tester0394' ) or die 'no tester0394';
my $u2 = LJ::load_user( 'tester0395' ) or die 'no tester0395';

my @tests;
print "Beginning tests...\n";
print "    u1 = " . $u1->user . '(' . $u1->id . ")\n";
print "    u2 = " . $u2->user . '(' . $u2->id . ")\n\n";

my $dbh = LJ::get_db_writer();

# reset, delete, etc
sub rst {
    $dbh->do( 'DELETE FROM wt_edges WHERE from_userid = ? OR to_userid = ?', undef, $_, $_ )
        foreach ( $u1->id, $u2->id );
    $dbh->do( 'DELETE FROM trust_groups WHERE userid = ?', undef, $_ )
        foreach ( $u1->id, $u2->id );

    foreach my $u ( $u1, $u2 ) {
        foreach my $mc ( qw/ trust_group wt_list / ) {
            LJ::memcache_kill( $u, $mc );
        }
    }
}

# return which bits are on (helper sub)
sub bits {
    my $mask = shift;
    return grep { $mask & ( 1<<$_ ) } 0..63;
}

################################################################################
push @tests, [ 'add to watching list', sub
{
    rst();
    $u1->add_edge( $u2, watch => { fgcolor => 123, bgcolor => 321, nonotify => 1 } );
    my $row = $dbh->selectrow_array(
            'SELECT COUNT(*) FROM wt_edges WHERE from_userid = ? AND to_userid = ? AND fgcolor = ? AND bgcolor = ? AND groupmask = ?',
            undef, $u1->id, $u2->id, 123, 321, 1<<61
        );
    die $dbh->errstr if $dbh->err;
    return ( $row > 0 ) ? 1 : 0;
} ];

################################################################################
push @tests, [ 'add to trust list', sub
{
    rst();
    $u1->add_edge( $u2, trust => { mask => 30004, nonotify => 1 } );
    my $row = $dbh->selectrow_array(
            'SELECT COUNT(*) FROM wt_edges WHERE from_userid = ? AND to_userid = ? AND groupmask = ?',
            undef, $u1->id, $u2->id, 30004 | 1
        );
    die $dbh->errstr if $dbh->err;
    return ( $row > 0 ) ? 1 : 0;
} ];

################################################################################
push @tests, [ 'watching list empty', sub
{
    my @ids = $u1->watched_userids;
    return scalar( @ids ) == 0 ? 1 : 0;
} ];

################################################################################
push @tests, [ 'trust list one member', sub
{
    my @ids = $u1->trusted_userids;
    return scalar( @ids ) == 1 ? 1 : 0;
} ];

################################################################################
push @tests, [ 'trust_list one member', sub
{
    my $ids = $u1->trust_list;
    return scalar( keys %$ids ) == 1 ? 1 : 0;
} ];

################################################################################
push @tests, [ 'mutually trust list empty', sub
{
    my @ids = $u1->mutually_trusted_userids;
    return scalar( @ids ) == 0 ? 1 : 0;
} ];

################################################################################
push @tests, [ 'add to trust list reverse', sub
{
    $u2->add_edge( $u1, trust => { mask => 30008, nonotify => 1 } );
    my $row = $dbh->selectrow_array(
            'SELECT COUNT(*) FROM wt_edges WHERE from_userid = ? AND to_userid = ? AND groupmask = ?',
            undef, $u2->id, $u1->id, 30008 | 1
        );
    die $dbh->errstr if $dbh->err;
    return ( $row > 0 ) ? 1 : 0;
} ];

################################################################################
push @tests, [ 'mutually trust lists one member', sub
{
    my @ids = $u1->mutually_trusted_userids;
    my @ids2 = $u2->mutually_trusted_userids;
    return ( scalar( @ids ) == 1 && scalar( @ids2 ) == 1 ) ? 1 : 0;
} ];

################################################################################
push @tests, [ 'remove from trust list', sub
{
    $u1->remove_edge( $u2, trust => { nonotify => 1 } );
    my $row = $dbh->selectrow_array(
            'SELECT COUNT(*) FROM wt_edges WHERE from_userid = ? AND to_userid = ? AND groupmask = ?',
            undef, $u1->id, $u2->id, 30004 | 1
        );
    die $dbh->errstr if $dbh->err;
    return ( $row == 0 ) ? 1 : 0;
} ];

################################################################################
push @tests, [ 'trust list empty', sub
{
    my @ids = $u1->trusted_userids;
    return scalar( @ids ) == 0 ? 1 : 0;
} ];

################################################################################
push @tests, [ 'trust_list empty', sub
{
    my $ids = $u1->trust_list;
    return scalar( keys %$ids ) == 0 ? 1 : 0;
} ];

################################################################################
push @tests, [ 'add to both lists', sub
{
    $u1->add_edge( $u2, watch => { nonotify => 1 }, trust => { nonotify => 1 } );
    my $row = $dbh->selectrow_array(
            'SELECT COUNT(*) FROM wt_edges WHERE from_userid = ? AND to_userid = ? AND groupmask = ?',
            undef, $u1->id, $u2->id, ( 1 << 61 ) | 1
        );
    die $dbh->errstr if $dbh->err;
    return ( $row > 0 ) ? 1 : 0;
} ];

################################################################################
push @tests, [ 'watching list one member', sub
{
    my @ids = $u1->watched_userids;
    return scalar( @ids ) == 1 ? 1 : 0;
} ];

################################################################################
push @tests, [ 'trust list one member', sub
{
    my @ids = $u1->trusted_userids;
    return scalar( @ids ) == 1 ? 1 : 0;
} ];

################################################################################
push @tests, [ 'watching list reverse one member', sub
{
    my @ids = $u2->watched_by_userids;
    return scalar( @ids ) == 1 ? 1 : 0;
} ];

################################################################################
push @tests, [ 'trust list reverse one member', sub
{
    my @ids = $u2->trusted_by_userids;
    return scalar( @ids ) == 1 ? 1 : 0;
} ];

################################################################################
push @tests, [ 'get full watch list', sub
{
    $u1->add_edge( $u1, trust => { nonotify => 1 } );

    my $hr = $u1->watch_list;
    return scalar( keys %$hr ) == 1 ? 1 : 0;
} ];

################################################################################
push @tests, [ 'add to both lists (one by one)', sub
{
    rst();
    $u1->add_edge( $u2, watch => { nonotify => 1 } );
    $u1->add_edge( $u2, trust => { nonotify => 1 } );
    my $row = $dbh->selectrow_array(
            'SELECT COUNT(*) FROM wt_edges WHERE from_userid = ? AND to_userid = ? AND groupmask = ?',
            undef, $u1->id, $u2->id, ( 1 << 61 ) | 1
        );
    die $dbh->errstr if $dbh->err;
    return ( $row > 0 ) ? 1 : 0;
} ];

################################################################################
push @tests, [ 'watching list one member', sub
{
    my @ids = $u1->watched_userids;
    return scalar( @ids ) == 1 ? 1 : 0;
} ];

################################################################################
push @tests, [ 'trust list one member', sub
{
    my @ids = $u1->trusted_userids;
    return scalar( @ids ) == 1 ? 1 : 0;
} ];

################################################################################
push @tests, [ 'watching list reverse one member', sub
{
    my @ids = $u2->watched_by_userids;
    return scalar( @ids ) == 1 ? 1 : 0;
} ];

################################################################################
push @tests, [ 'trust list reverse one member', sub
{
    my @ids = $u2->trusted_by_userids;
    return scalar( @ids ) == 1 ? 1 : 0;
} ];

################################################################################
push @tests, [ 'get full watch list', sub
{
    my $hr = $u1->watch_list;
    return scalar( keys %$hr ) == 1 ? 1 : 0;
} ];

################################################################################
push @tests, [ 'add to trust and watch lists', sub
{
    rst();
    $u1->add_edge( $u2, trust => { mask => 30004, nonotify => 1 }, watch => { nonotify => 1} );
    my $row = $dbh->selectrow_array(
            'SELECT COUNT(*) FROM wt_edges WHERE from_userid = ? AND to_userid = ?',
            undef, $u1->id, $u2->id
        );
    die $dbh->errstr if $dbh->err;
    return ( $row > 0 ) ? 1 : 0;
} ];

################################################################################
push @tests, [ 'remove from watch list', sub
{
    $u1->remove_edge( $u2, watch => { nonotify => 1 } );
    my $row = $dbh->selectrow_array(
            'SELECT COUNT(*) FROM wt_edges WHERE from_userid = ? AND to_userid = ?',
            undef, $u1->id, $u2->id
        );
    die $dbh->errstr if $dbh->err;
    return ( $row > 0 ) ? 1 : 0;
} ];

################################################################################
push @tests, [ 'watching list empty', sub
{
    my @ids = $u1->watched_userids;
    return scalar( @ids ) == 0 ? 1 : 0;
} ];

################################################################################
push @tests, [ 'trust list one member', sub
{
    my @ids = $u1->trusted_userids;
    return scalar( @ids ) == 1 ? 1 : 0;
} ];

################################################################################
push @tests, [ 'add to watch list with colors', sub
{
    rst();
    $u1->add_edge( $u2, watch => { fgcolor => 255, bgcolor => 255, nonotify => 1 } );
    my $row = $dbh->selectrow_array(
            'SELECT COUNT(*) FROM wt_edges WHERE from_userid = ? AND to_userid = ?',
            undef, $u1->id, $u2->id
        );
    die $dbh->errstr if $dbh->err;
    return ( $row > 0 ) ? 1 : 0;
} ];

################################################################################
push @tests, [ 'validate colors', sub
{
    my $hr = $u1->watch_list;
    die unless scalar( keys %$hr ) == 1 ? 1 : 0;
    return ( $hr->{$u2->id}->{fgcolor} eq '#0000ff' && $hr->{$u2->id}->{bgcolor} eq '#0000ff' ) ? 1 : 0;
} ];

################################################################################
push @tests, [ 'add to watch list again', sub
{
    $u1->add_edge( $u2, watch => { nonotify => 1 } );
    my $row = $dbh->selectrow_array(
            'SELECT COUNT(*) FROM wt_edges WHERE from_userid = ? AND to_userid = ?',
            undef, $u1->id, $u2->id
        );
    die $dbh->errstr if $dbh->err;
    return ( $row > 0 ) ? 1 : 0;
} ];

################################################################################
push @tests, [ 'validate colors again', sub
{
    my $hr = $u1->watch_list;
    die unless scalar( keys %$hr ) == 1 ? 1 : 0;
    return ( $hr->{$u2->id}->{fgcolor} eq '#0000ff' && $hr->{$u2->id}->{bgcolor} eq '#0000ff' ) ? 1 : 0;
} ];

################################################################################
push @tests, [ 'create trust group', sub
{
    rst();
    my $id = $u1->create_trust_group( groupname => 'foo group', sortorder => 10, is_public => 1 );
    my $row = $dbh->selectrow_array(
            'SELECT COUNT(*) FROM trust_groups WHERE userid = ? AND groupname = ? AND sortorder = ? AND is_public = ?',
            undef, $u1->id, 'foo group', 10, 1
        );
    die $dbh->errstr if $dbh->err;
    return ( $row > 0 ) ? 1 : 0;
} ];

################################################################################
push @tests, [ 'get trust group', sub
{
    my $grp = $u1->trust_groups;
    return scalar( keys %$grp ) > 0 ? 1 : 0;
} ];

################################################################################
push @tests, [ 'edit trust group', sub
{
    $u1->edit_trust_group( id => 1, groupname => 'bar group' );
    my $row = $dbh->selectrow_array(
            'SELECT COUNT(*) FROM trust_groups WHERE userid = ? AND groupname = ? AND sortorder = ? AND is_public = ?',
            undef, $u1->id, 'bar group', 10, 1
        );
    die $dbh->errstr if $dbh->err;
    return ( $row > 0 ) ? 1 : 0;
} ];

################################################################################
push @tests, [ 'get trust group again', sub
{
    my $grp = $u1->trust_groups;
    return ( $grp->{1}->{groupname} eq 'bar group' ) ? 1 : 0;
} ];

################################################################################
push @tests, [ 'validate trustmask == 1', sub
{
    rst();

    # have to create a group with a known id for these tests
    $u1->edit_trust_group( id => 1, groupname => 'bar group', _force_create => 1 );

    $u1->add_edge( $u2, trust => { nonotify => 1 } );
    return ( $u1->trustmask( $u2 ) == 1 ) ? 1 : 0;
} ];

################################################################################
push @tests, [ 'validate nobody in group 1', sub
{
    my $ids = $u1->trust_group_list( id => 1 );
    return ( scalar ( keys %$ids ) == 0 ) ? 1 : 0;
} ];

################################################################################
push @tests, [ 'add to group, validate trustmask == 3', sub
{
    $u1->edit_trustmask( $u2, add => 1 );
    return ( $u1->trustmask( $u2 ) == 3 ) ? 1 : 0;
} ];

################################################################################
push @tests, [ 'validate in group 1', sub
{
    my $ids = $u1->trust_group_list( id => 1 );
    return ( scalar ( keys %$ids ) == 1 ) ? 1 : 0;
} ];

################################################################################
push @tests, [ 'add two more groups', sub
{
    $u1->edit_trustmask( $u2, add => [ 1, 3 ] );
    return ( $u1->trustmask( $u2 ) == 11 ) ? 1 : 0;
} ];

################################################################################
push @tests, [ 'remove group', sub
{
    $u1->edit_trustmask( $u2, remove => [ 1 ] );
    return ( $u1->trustmask( $u2 ) == 9 ) ? 1 : 0;
} ];

################################################################################
push @tests, [ 'set groups', sub
{
    $u1->edit_trustmask( $u2, set => [ 4, 3 ] );
    return ( $u1->trustmask( $u2 ) == 25 ) ? 1 : 0;
} ];

################################################################################
push @tests, [ 'test contains', sub
{
    $u1->trust_group_contains( $u2, 3 ) == 1 or return 0;
    $u1->trust_group_contains( $u2, 4 ) == 1 or return 0;
    $u1->trust_group_contains( $u2, 5 ) == 0 or return 0;
    return 1;
} ];


################################################################################
push @tests, [ 'delete trust group 3', sub
{
    # have to create a group with a known id for these tests
    $u1->edit_trust_group( id => 3, groupname => 'bar group 3', _force_create => 1 );

    $u1->trust_group_contains( $u2, 3 ) == 1 or return 0;
    $u1->trust_group_contains( $u2, 4 ) == 1 or return 0;
    $u1->trust_group_contains( $u2, 5 ) == 0 or return 0;

    # now delete the group
    $u1->delete_trust_group( name => 'bar group 3' ) or return 0;

    $u1->trust_group_contains( $u2, 3 ) == 0 or return 0;
    $u1->trust_group_contains( $u2, 4 ) == 1 or return 0;
    $u1->trust_group_contains( $u2, 5 ) == 0 or return 0;

    # validate group doesn't fetch
    $u1->trust_groups( name => 'bar group 3' ) and return 0;

    return 1;
} ];

################################################################################
push @tests, [ 'clear groups', sub
{
    $u1->edit_trustmask( $u2, set => [] );
    return ( $u1->trustmask( $u2 ) == 1 ) ? 1 : 0;
} ];

################################################################################
push @tests, [ 'reset, add mask', sub
{
    rst();
    $u1->add_edge( $u2, trust => { mask => 12, nonotify => 1 } );
    return ( $u1->trustmask( $u2 ) == 13 ) ? 1 : 0;
} ];

################################################################################
push @tests, [ 'add edge again, test mask', sub
{
    $u1->add_edge( $u2, trust => { nonotify => 1 } );
    return ( $u1->trustmask( $u2 ) == 13 ) ? 1 : 0;
} ];

################################################################################
push @tests, [ 'allowed to watch and trust', sub
{
    return ( $u1->can_watch && $u2->can_trust ) ? 1 : 0;
} ];

################################################################################
push @tests, [ 'allowed to watch and trust the other', sub
{
    return ( $u1->can_watch( $u2 ) && $u2->can_trust( $u2 ) ) ? 1 : 0;
} ];

################################################################################
$| = 1;
my $id = 1;
foreach my $test ( @tests ) {
    print "Test #$id: $test->[0]: ";
    my $rv = 0;
    eval {
        $rv = $test->[1]->();
    };
    if ( $@ || $rv == 0 ) {
        print "failure!\n\n\$@ = $@\n\$! = $!\nrv = $rv\n\n";
        die;
    } else {
        print "success\n";
    }
    $id++;
}
