<?_code
{
    use strict;
    use vars qw(%GET %POST $title $body $head @errors);
    use Carp qw(croak);

    LJ::set_active_crumb('manageuserpics');
    BML::set_language_scope("/editpics.bml");

    my $suffix = "";
    if (Apache->request->uri =~ /editpics-beta/) {
        $suffix = "-beta";
    }

    $title = $ML{'.title3'};
    $body = "";
    @errors = ();

    my $err = sub {
        $title = $ML{'Error'};
        $body = LJ::bad_input(@_);
        return;
    };

    unless (LJ::text_in(\%POST)) {
        return $err->("Invalid UTF-8 Input");
    }

    my $remote = LJ::get_remote();
    unless ($remote) {
        $body = "<?needlogin?>";
        return;
    }

    if ($remote->underage) {
        return BML::redirect("$LJ::SITEROOT/agecheck/?s=1");
    }

    LJ::need_res(qw(
                    stc/lj_base.css
                    stc/editpics.css
                    js/progressbar.js
                    js/ljprogressbar.js
                    js/perlbal-uploadtrack.js
                    js/editpics.js
                    ));

    my $authas = $GET{'authas'} || $remote->{'user'};
    my $u = LJ::get_authas_user($authas) or
        return $err->($ML{'error.invalidauth'});

    # extra arguments for get requests
    my $getextra = $authas ne $remote->{'user'} ? "?authas=$authas" : '';

    my $returl = LJ::CleanHTML::canonical_url($POST{'ret'});
    my $picurl = LJ::CleanHTML::canonical_url($POST{'urlpic'});
    my $fotobilder = index($returl, $LJ::FB_SITEROOT) == 0 &&
        $picurl =~ m!^$LJ::FB_SITEROOT/~?$remote->{'user'}/pic/!;

    if ($fotobilder &&
        (LJ::check_referer($returl) || LJ::check_referer('/editpics.bml'))) {

        return $err->('Invalid referring site or redirection not allowed')
            unless $returl =~ /$LJ::FB_DOMAIN/ && LJ::get_cap($u, 'fb_account');
    }

    if (LJ::get_cap($u, "readonly")) {
        $title = "Read-only mode";
        $body = $LJ::MSG_READONLY_USER;
        return;
    }

    # update this user's activated pics
    $u->activate_userpics;

    # get userpics and count 'em
    my @userpics = LJ::Userpic->load_user_userpics($u);

    # get maximum number of userpics for this user
    my $max      = LJ::get_cap($u, "userpics");

    my @info;

    ### save mode
    if (LJ::did_post()) {

        ### save changes to existing pics
        if ($POST{'action:save'}) {
            # form being posted isn't multipart, since we were able to read from %POST
            unless (LJ::check_form_auth()) {
                return $err->($ML{'error.invalidform'});
            }

            my @delete; # userpic objects to delete
            my @inactive_picids;
            my %picid_of_kwid;
            my %used_keywords;

            # we need to count keywords based on what the user provided, in order
            # to find duplicates. $up->keywords doesn't work, because re-using a
            # keyword will remove it from the other userpic without our knowing
            my $count_keywords = sub {
                my $kwlist = shift;
                $used_keywords{$_}++ foreach split(/,\s*/, $kwlist);
            };

            foreach my $up (@userpics) {
                my $picid = $up->id;

                # delete this pic
                if ($POST{"delete_$picid"}) {
                    push @delete, $up;
                    next;
                }

                # we're only going to modify keywords/comments on active pictures
                if ($up->inactive) {
                    # use 'orig' because we don't POST disabled fields
                    $count_keywords->($POST{"kw_orig_$picid"});
                    next;
                }

                $count_keywords->($POST{"kw_$picid"});

                # only modify if changing the data, make sure not collidiing with other edits, etc
                if ($POST{"kw_$picid"} ne $POST{"kw_orig_$picid"}) {
                    my $kws = $POST{"kw_$picid"};

                    eval {
                        $up->set_keywords($kws);
                    } or push @errors, $@;

                }

                eval {
                    $up->set_comment ($POST{"com_$picid"})
                        unless $POST{"com_$picid"} eq $POST{"com_orig_$picid"};
                } or push @errors, $@;
            }

            foreach my $kw (keys %used_keywords) {
                next unless $used_keywords{$kw} > 1;
                push @errors, BML::ml('.error.keywords', {ekw => $kw});
            }

            if (@delete && $LJ::DISABLE_MEDIA_UPLOADS) {
                push @errors, $ML{'.error.nomediauploads.delete'};

            } elsif (@delete) {

                # delete pics
                foreach my $up (@delete) {
                    eval { $up->delete; } or push @errors, $@;
                }

                # if any of the userpics they want to delete are active, then we want to
                # re-run activate_userpics() - turns out it's faster to not check to
                # see if we need to do this
                $u->activate_userpics;
            }

            my $new_default = $POST{'defaultpic'}+0;
            if ($POST{"delete_${new_default}"}) {
                # deleting default
                $new_default = 0;
            }

            if ($new_default && $new_default != $u->{'defaultpicid'}) {
                my ($up) = grep { $_->id == $new_default } @userpics;

                # see if they are trying to make an inactive userpic their default
                if ($up && !$up->inactive) {
                    $up->make_default;
                }
            } elsif ($new_default eq '0' && $u->{'defaultpicid'}) {
                # selected the "no default picture" option
                LJ::update_user($u, { defaultpicid => 0 });
                  $u->{'defaultpicid'} = 0;
              }

            # reload the pictures to account for deleted
            @userpics = LJ::Userpic->load_user_userpics($u) if scalar @delete;
        }

        ### no post data, so we'll parse the multipart data
        unless (%POST) {

            my $r = Apache->request;
            my $size = $r->header_in("Content-length");
            unless ($size) {
                return $err->("No content-length header: can't upload");
            }

            my $MAX_UPLOAD = LJ::Userpic->max_allowed_bytes($u);
            my $error;

            # act like the factory is disabled if no mogile
            my $factory_disabled = $LJ::DISABLED{'userpicfactory'} || !LJ::mogclient();

            # file over 40k, return too large error
            if ($factory_disabled && ($size > $MAX_UPLOAD + 2048)) {
                # we have to suck in the data otherwise the browser gets upset because we're
                # closing the connection before reading in all the data and it will sometimes
                # refuse to show the error.

                # pretend to tell apache that we care about parsing the data, but we really don't
                my $bogus = sub {return 1;};
                BML::parse_multipart_interactive($r, \$error, {
                    newheaders => $bogus,
                    data       => $bogus,
                    enddata    => $bogus,
                });

                return $err->(BML::ml('.error.filetoolarge',
                                      { 'maxsize' => int($MAX_UPLOAD / 1024) .
                                            $ML{'.kilobytes'} }));
            }

            my $gotofactory = !$factory_disabled && ($size > $MAX_UPLOAD + 2048);

            # small file size, check the pic out
            if (!$gotofactory) {
                BML::parse_multipart(\%POST, \$error, $MAX_UPLOAD + 2048);

                  # couldn't parse correctly
                  if ($error) {
                      # return parse_multipart error
                      return $err->($error);
                  }

                  if ($POST{'userpic'}) {
                      my ($imagew, $imageh, $filetype) = Image::Size::imgsize(\$POST{'userpic'});

                      return $err->(BML::ml(".error.unsupportedtype", {filetype => $filetype}))
                          if (!$imagew || !$imageh);

                      # we need to double-check the filesize here; we made it past the initial check because
                      # the factory isn't disabled, but the factory doesn't work for GIF userpics
                      return $err->(BML::ml('.error.filetoolarge', { 'maxsize' => int($MAX_UPLOAD / 1024) . $ML{'.kilobytes'} }))
                          if ($filetype eq 'GIF' && ($size > $MAX_UPLOAD + 2048));

                      if (int($imagew) > 100 || int($imageh) > 100) {
                          if ($factory_disabled) {
                              # less than 40k, greater than 100x100 and factory is disabled
                              return $err->(BML::ml('.error.imagetoolarge', {imagesize => "${imagew}x$imageh"}));
                          } elsif ($filetype ne 'JPG' && $filetype ne 'PNG') {
                              # factory only works on jpegs and pngs because Image::Magick has issues
                              return $err->("Sorry, you cannot upload a userpic larger than 100x100 pixels if it is in GIF format.")
                          } else {
                              # large image size, to the factory!
                              $gotofactory = 1;
                          }
                      }
                  }
              }

            # if we're coming from the factory, we definitely don't want to go back!
            $gotofactory = 0 if ($POST{'src'} && $POST{'src'} eq 'factory');

            if ($gotofactory) {
                # large path

                my %upload = (); # { spool_fh, spool_path, filename, bytes, md5sum, md5ctx, mime }
                my $curr_name;

                # called when the beginning of an upload is encountered
                my $hook_newheaders = sub {
                    my ($name, $filename) = @_;

                    # for uploaded files, just set POST value to filename
                    $POST{$name} = '';

                    $curr_name = $name;

                    return 1 unless $curr_name eq 'userpic';

                    # new file, need to create a filehandle, etc
                    $upload{filename} = $filename;
                    $upload{md5ctx} = new Digest::MD5;

                    # get MogileFS filehandle
                    return $err->("Sorry, MogileFS must be running to handle the uploading of large images.") unless LJ::mogclient();

                    $upload{spool_fh} = LJ::mogclient()->new_file("upf:$u->{userid}", 'temp')
                        or die "Failed to open MogileFS tempfile";

                    return 1;
                };

                # called as data is received
                my $hook_data = sub {
                    my ($len, $data) = @_;

                    unless ($curr_name eq 'userpic') {
                        $POST{$curr_name} .= $data;
                        return 1;
                    }

                    # check that we've not exceeded the max read limit
                    my $max_read = (1<<20) * 5; # 5 MiB
                    my $len_read = 0;

                    $len_read = ($upload{bytes} += $len);

                    die "Upload max exceeded at $len_read bytes"
                        if $len_read > $max_read;

                    $upload{md5ctx}->add($data);
                    $upload{spool_fh}->print($data);

                    return 1;
                };

                # called when the end of an upload is encountered
                my $hook_enddata = sub {
                    return 1 unless $curr_name eq 'userpic';

                    # since we've just finished a potentially slow upload, we need to
                    # make sure the database handles in DBI::Role's cache haven't expired,
                    # so we'll just trigger a revalidation now so that subsequent database
                    # calls will be safe.
                    $LJ::DBIRole->clear_req_cache();

                    # don't try to operate on 0-length spoolfiles
                    unless ($upload{bytes}) {
                        %upload = ();
                        return 1;
                    }

                    # read magic and try to determine formatid of uploaded file. This
                    # doesn't use fh->tell and fh->seek because the filehandle is
                    # sysopen()ed, so isn't really an IO::Seekable like an IO::File
                    # filehandle would be.
                    my $magic;
                    tell $upload{spool_fh}
                    or die "read offset is 0, empty file?";
                    seek $upload{spool_fh}, 0, 0;

                    # $! should always be set in this case because a failed read will
                    # always be an error, not EOF, which is handled above (tell)
                    $upload{spool_fh}->read($magic, 20)
                        or die "Couldn't read magic: $!";

                    $upload{spool_fh}->close
                        or die "Can't close Mogile filehandle";

                    my $format_magic = sub {
                        my $magic = shift;
                        my $hex = unpack "H*", $magic;
                        my $mime;

                        # image formats
                        $mime = 'image/jpeg' if $magic =~ /^\xff\xd8/; # JPEG
                        $mime = 'image/gif'  if $magic =~ /^GIF8/;     # GIF
                        $mime = 'image/png'  if $magic =~ /^\x89PNG/;  # PNG

                        return $mime;
                    };

                    $upload{mime} = $format_magic->($magic)
                        or die "Unknown format for upload";

                    # finished adding data for md5, create digest (but don't destroy original)
                    $upload{md5sum} = $upload{md5ctx}->digest;

                    return 1;
                };

                my $res = 1;

                if ($POST{userpic}) {
                    # we already have the oversize pic, just stash it directly in mogile
                    LJ::mogclient()->store_content("upf:$u->{userid}", "temp", \$POST{userpic});
                  } else {
                      # parse multipart-mime submission, one chunk at a time,
                      # calling our hooks as we go to put uploads in temporary
                      # MogileFS filehandles
                      $res = eval { BML::parse_multipart_interactive($r, \$error, {
                          newheaders => $hook_newheaders,
                          data       => $hook_data,
                          enddata    => $hook_enddata,
                      }); };

                      # we didn't know that the image was a gif until now, but since we do,
                      # we can enforce GIF-specific error conditions
                      if ($upload{mime} eq 'image/gif') {

                          # can't be over 40k
                          if ($size > $MAX_UPLOAD + 2048) {
                              return $err->(BML::ml('.error.giffiletoolarge', 
                                                    { 'maxsize' => int($MAX_UPLOAD / 1024) . $ML{'.kilobytes'} }));
                          }

                          # sorry, factory only works for jpegs and pngs
                          return $err->("Sorry, you cannot upload a userpic larger than 100x100 pixels if it is in GIF format.")
                      }
                }

                # if BML::Parse_multipart_interactive failed, we need to add
                # all of our gpics to the gpic_delete queue.  if any of them
                # still have refcounts, they won't really be deleted because
                # the async job will realize and leave them alone
                unless ($res) {
                    if (index(lc($error), 'unknown format') == 0) {
                        LJ::mogclient()->delete("upf:$u->{userid}");
                        return $err->(BML::ml(".error.unknowntype"));
                    }
                    return $err->("couldn't parse upload: $error");
                }

                my $imgdata = $POST{userpic} ? \$POST{userpic} : $upload{spool_fh};
                my ($imagew, $imageh, $filetype) = Image::Size::imgsize($imgdata);

                return $err->("The dimensions of this image are too large.") if ($imagew > 5000 || $imageh > 5000);

                # if image is >40k but under 100x100 try to compress it down
                my $bytes = $POST{userpic} ? length($POST{userpic}) : $upload{bytes};
                return $err->("Could not determine size of uploaded file") unless $bytes;

                my $nofactory = 0;

                if (($imagew <= 100 && $imageh <= 100) && $bytes > $MAX_UPLOAD) {
                    # attempt to resize down
                    eval {
                        my $picinfo = LJ::get_upf_scaled(
                                                         size => 100,
                                                         u    => $u,
                                                         );

                        # success! don't go to the factory, and pretend the user just uploaded the file
                        # and continue on normally
                        $POST{userpic} = ${$picinfo->[0]};
                        $nofactory = 1;
                    };

                    if ($@ || length($POST{userpic}) > $MAX_UPLOAD) {
                        return $err->(BML::ml('.error.filetoolarge',
                                              {maxsize => int($MAX_UPLOAD / 1024) . $ML{'.kilobytes'}}));
                    }
                }

                return BML::redirect("$LJ::SITEROOT/tools/userpicfactory.bml?keywords=" .
                                     BML::eurl($POST{'keywords'}) . "&comments=" .
                                     BML::eurl($POST{'comments'}) . "&imageWidth=${imagew}&imageHeight=${imageh}".
                                     "&make_default=" . BML::eurl($POST{'make_default'}) . '&authas=' .
                                     BML::eurl($GET{'authas'}) . '&sfx=' . BML::eurl($suffix)) unless $nofactory;
            }

            # was there an error parsing the multipart form?
            if ($error) {
                if ($error =~ /^\[(\S+?)\]/) {
                    my $code = $1;
                    if ($code eq "toolarge") {
                        return $err->(BML::ml('.error.filetoolarge',
                                              { 'maxsize' => int($MAX_UPLOAD / 1024) .
                                                    $ML{'.kilobytes'} }));
                    }
                    $error = BML::ml("BML.parse_multipart.$code");
                }
                return $err->($error) if $error;
            }

            # error check input contents
            if ($POST{'src'} eq "url" && $POST{'urlpic'} !~ /^http:\/\//) {
                return $err->($ML{'.error.badurl'});
            }

            if ($POST{'src'} eq "file")  {
                # already loaded from multipart parse earlier
                return $err->("You must choose a file to upload or enter the URL of an image") unless $POST{'userpic'};
            } elsif ($POST{'src'} eq "factory") {
                my $scaledsizemax = $POST{'scaledSizeMax'};
                my $x1 = $POST{'x1'}+0;
                my $x2 = $POST{'x2'}+0;
                my $y1 = $POST{'y1'}+0;
                my $y2 = $POST{'y2'}+0;

                return $err->("Invalid userpic creation parameters.") if (!$scaledsizemax || !$x2);

                my $picinfo = eval {
                    LJ::get_upf_scaled(
                                       x1 => $x1,
                                       y1 => $y1,
                                       x2 => $x2,
                                       y2 => $y2,
                                       border => $POST{'border'},
                                       userid  => $u->id,
                                       );
                  }
                or return $err->("There was an error in generating the userpic: $@");

                $POST{userpic} = ${ $picinfo->[0] };

            } elsif ($POST{'src'} eq "url") {
                my $ua = LJ::get_useragent(
                                           role     => 'userpic',
                                           max_size => $MAX_UPLOAD + 1024,
                                           timeout  => 10,
                                           );
                my $res = $ua->get($POST{urlpic});
                $POST{userpic} = $res->content if $res && $res->is_success;
                return $err->($ML{'.error.urlerror'}) unless $POST{userpic};
                return $err->("You cannot upload large images from URLs.") if length($POST{userpic}) > $MAX_UPLOAD;
            }

            ## see if they have too many pictures uploaded
            my $inline;
            if (scalar @userpics >= $max) {
                if ($inline .= LJ::run_hook("cprod_inline", $u, 'EditPicsMax')) {
                    return $err->($inline . LJ::help_icon('userpics', " ", ""));
                } else {
                    return $err->(BML::ml('.error.toomanypics4', { "num" => $max }). LJ::help_icon('userpics', " ", ""));
                }
            }

            my $userpic = eval { LJ::Userpic->create($u, data => \$POST{'userpic'}); };
            if (!$userpic) {
                return $err->($@->as_string);
            }

            my $picid = $userpic->id;

            push @info, "Your userpic has been successfully uploaded";

            # make it their default pic?
            if ($POST{'make_default'}) {
                $userpic->make_default;
            }

            $userpic->set_keywords($POST{'keywords'}) if $POST{'keywords'};
            $userpic->set_comment($POST{'comments'})  if $POST{'comments'};
            $userpic->set_fullurl($POST{'url'})       if $POST{'url'};

            # redirect back to ourselves/fotobilder
            $returl = LJ::CleanHTML::canonical_url($POST{'ret'});
            if ($returl) {
                my $redir_host = $1 if $returl =~ m!^http://([\.:\w-]+)!i;
                return BML::redirect($returl) if $LJ::REDIRECT_ALLOWED{$redir_host};
            }

            # yey we created a new pic, reload the @userpics
            @userpics = LJ::Userpic->load_user_userpics($u);
        }

        # now fall through to edit page and show the updated userpic info
    }

    if ($fotobilder && $POST{'md5sum'}) {
        $fotobilder = 0 if LJ::Userpic->new_from_md5($u, $POST{'md5sum'});
    }

    if (!$fotobilder) {
        # authas switcher form
        $body .= "<form method='get' id='userpic_authas' action='editpics$suffix.bml'>\n";
        $body .= LJ::make_authas_select($remote, { 'authas' => $GET{'authas'} }) . "\n";
        $body .= "</form>\n\n";
    }

    # if we're disabling media, say so
    $body .= "<?warningbar $ML{'error.mediauploadsdisabled'} warningbar?>"
        if $LJ::DISABLE_MEDIA_UPLOADS;

    if (@info) {
        $body .= '<div class="warningbar">';
        $body .= "<div>$_</div>" foreach @info;
        $body .= '</div>';
    }

    # print out upload pic box
    my $emit_upload_box = sub {
        $body .= '<a name="uploadBox"></a>';
        if (scalar @userpics < $max) {
            
            # upload form (with perlbal upload-tracking)
            $body .= qq {
                <iframe name='upiframe' width='1' height='1' style='border: none'></iframe>
                <div id='uploadBox' class='pkg'><div id='uploadBox-inner'>
                    <form enctype="multipart/form-data" action="editpics$suffix.bml$getextra" method='post' id='uploadPic'>
                    <input type="hidden" id="go_to" name="go_to" value="editpics$suffix.bml$getextra" />
            };
            if ($fotobilder) {
                $body .= "<?h1 $ML{'.uploadheader.fb'} h1?>\n";
                $body .= "<?p " . BML::ml('.uploaddesc.fb', {'aopts' => "href='$LJ::FB_SITEROOT'", 'sitename' => $LJ::FB_SITENAME}) . " p?>\n\n";
            } else {
                $body .= "<?h1 $ML{'.uploadheader'} h1?>\n";
                $body .= "<p class='detail'><a href='javascript:void(0)' onclick='toggleElement(\"upload_desc\")' id='upload_desc_link'>About Userpics</a></p>";
                $body .= "<div id='upload_desc'>";
                $body .= "<?p $ML{'.uploaddesc'} p?>\n";
                $body .= "</div><!-- end #uploaddesc -->";
            }
            if ($fotobilder) {
                $body .= "<img src='$picurl' />";
                my $url = LJ::CleanHTML::canonical_url($POST{'url'});
                $body .= LJ::html_hidden('src', 'url', 'urlpic', $picurl, 'url', $url, 'ret' => $returl);
            } else {
                $body .= "<div id='upload_wrapper' class='pkg'>\n";
                $body .= "<p class='pkg'>\n";
                $body .= LJ::html_check({ 'type' => 'radio', 'name' => 'src', 'id' => 'radio_file',
                                          'class' => 'radio', 'value' => 'file', 'selected' => '1', 
                                          'accesskey' => $ML{'.fromfile.key'} }) . "\n";
                $body .= "<label class='left' for='radio_file'>$ML{'.fromfile'}</label>\n";
                $body .= "<input type='file' class='file' name='userpic' size='22' />\n";
                $body .= "</p>\n";
                $body .= "<p class='pkg'>\n";
                $body .= LJ::html_check({ 'type' => 'radio', 'name' => 'src', 'value' => 'url',
                                          'id' => 'radio_url', 'class' => 'radio', 'accesskey' => $ML{'.fromurl.key'} }) . "\n";
                $body .= "<label class='left' for='radio_url'>$ML{'.fromurl'}</label>";
                $body .= LJ::html_text({ 'name' => 'urlpic', class => 'text' }) . "\n";
                $body .= "</p>\n";
                $body .= "<p class='detail'>$ML{'.label.formats.desc'}</p>\n";
                $body .= "</div>\n";
            }

            $body .= "<hr class='hr' />";

            $body .= "<p class='pkg'>\n";
            $body .= "<label class='left' for='keywords'>$ML{'.label.keywords'}</label>\n";
            $body .= "<span class='input-wrapper'>";
            $body .= LJ::html_text({ 'name' => 'keywords', class => 'text', id => 'keywords' }) . "\n";
            $body .= LJ::help_icon_html('upic_keywords') . "\n";
            $body .= "</span>";
            $body .= "</p>\n";
            $body .= "<p class='detail'>$ML{'.label.keywords.desc'}</p>\n";

            if (LJ::Userpic->user_supports_comments($u)) {
                $body .= "<p class='pkg'>\n";
                $body .= "<label class='left' for='comments'>$ML{'.label.comment'}</label>\n";
                my $comments = $POST{'comments'} if $fotobilder;
                $body .= "<span class='input-wrapper'>";
                $body .= LJ::html_text({ 'name' => 'comments', 'class' => 'text', id => 'comments', 'maxlength' => LJ::CMAX_UPIC_COMMENT, 'value', $comments }) . "\n";
                $body .= LJ::help_icon_html('upic_comments') . "\n";
                $body .= "</span>";
                $body .= "</p>\n";
                $body .= "<p class='detail'>$ML{'.label.comment.desc'}</p>\n";
            }

            $body .= "<p class='pkg'>\n";
            $body .= LJ::html_check({ 'type' => 'checkbox',
                                      'name' => 'make_default',
                                      'id' => 'make_default',
                                      'value' => '1',
                                      'selected' => @userpics ? 0 : 1,
                                      'accesskey' => $ML{'.makedefault.key'} });

            $body .= "<label for='make_default'>$ML{'.makedefault'}</label>\n";
            $body .= "</p>\n";
            
            $body .= "<p class='pkg' id='submit_wrapper'>";
            $body .= LJ::html_submit(undef, $ML{'.btn.proceed'},
                                     { disabled => $LJ::DISABLE_MEDIA_UPLOADS });
            $body .= "</p>\n";
            $body .= q {
                    </form>
                    </div></div><!-- end #uploadBox -->
                    <div id="uploadStatus" style="display: none;"></div>
                    <div id="progressBar" style="display: none;"></div>
                };

        } else {
            $body .= "<div id='limit'>\n";
            my $inline;
            if ($inline .= LJ::run_hook("cprod_inline", $u, 'EditPicsMax')) {
                $body .= $inline;
            } else {
                $body .= BML::ml('.error.toomanypics_standout', { num => $max });
            }
            $body .= "</div><!-- end #limit -->";
        }
        $body .= " \n\n";
    };

    $emit_upload_box->();

    # print out each pic and editing fields
    if (scalar @userpics && !$fotobilder) {
        $body .= "<div id='current_userpics'>";
        $body .= "<form method='post' action='editpics$suffix.bml$getextra'>";
        $body .= LJ::form_auth();

        $body .= qq {
                <?h1 $ML{'.curpics'} h1?>
                <?p $ML{'.curpics.desc2'} p?>
                <div class='EditPicsStatus'>
            };

        $body .= "<p><strong>" . BML::ml('.piclimitstatus', {current => scalar @userpics, max => $max}) . "</strong></p>";;
        if (scalar @userpics >= $max) {
            my $inline;
            if ($inline .= LJ::run_hook("cprod_inline", $u, 'EditPics')) {
                $body .= "<?warningbar" . $inline . "warningbar?>";
            } else {
                $body .= "<p>".BML::ml('cprod.editpics.text7.v1',{ "num" => $max })."</p>";
            }
        }
        $body .= "</div>";

        $body .= "<div id='list_userpics' style='width: 100%; float: left;'>";
        foreach my $pic (@userpics) {
            my $pid = $pic->id;

            $body .= "<div class='pkg userpic_wrapper'>";
            $body .= "<span class='EditPicsUserpic'><img src='$LJ::USERPIC_ROOT/$pid/$u->{'userid'}' width='$pic->{'width'}' height='$pic->{'height'}' /></span>\n";

            # TODO: if no keywords then light grey text and empty out when you click in it
            my $keywords = $pic->keywords;
            my $comment = $pic->comment;
            $body .= "<div class='userpic_controls'  style='float: left;'>";
            $body .= "<div class='userpic_keywords pkg'>\n";
            $body .= "<label class='left' for='kw_$pid'>$ML{'.label.keywords'}</label>\n ";
            $body .= LJ::html_text({'name' => "kw_$pid", 'class' => "text", 'id' => "kw_$pid",
                                    'value' => $keywords,
                                    'disabled' => $pic->inactive }) . "\n";
            $body .= LJ::html_hidden({ 'name' => "kw_orig_$pid",
                                       'value' => $keywords }) . "\n";
            $body .= "</div>\n";

            if ($pic->supports_comments) {
                $body .= "<div class='userpic_comments pkg'>\n";
                $body .= "<label class='left' for='com_$pid'>$ML{'.label.comment'}</label>\n ";
                $body .= LJ::html_text({ 'name' => "com_$pid", 'class' => "text", 'id' => "com_$pid",
                                         'value' => $comment,
                                         'maxlength' => LJ::CMAX_UPIC_COMMENT,
                                         'disabled' => $pic->inactive }) . "\n";
                $body .= LJ::html_hidden({ 'name' => "com_orig_$pid",
                                           'value' => $comment }) . "\n";

                $body .= "</div>\n";
            }
            
            $body .= "<div class='userpic_defaultdelete pkg'>";
            $body .= LJ::html_check({ 'type' => 'radio', 'name' => 'defaultpic', 'class' => "radio", 'value' => $pid,
                                      'selected' => $pic->is_default ? 1 : 0,
                                      'id' => "def_$pid",
                                      'disabled' => $pic->inactive });
            $body .= "<label class='userpic_default_label' for='def_$pid'>$ML{'.label.default'}</label> ";
            $body .= LJ::html_check({ 'type' => 'checkbox', 'name' => "delete_$pid", 'class' => "checkbox",
                                      'id' => "del_$pid", 'value' => 1,
                                      'disabled' => $LJ::DISABLE_MEDIA_UPLOADS });
            $body .= "<label for='del_$pid'>$ML{'.label.delete'}</label>"; 
            if ($pic->inactive) {
                $body .= " &nbsp;<i>[$ML{'userpic.inactive'}]</i> " . LJ::help_icon('userpic_inactive');
            }
            $body .= "</div>";
            $body .= "</div>";
            $body .= "</div>";
            $body .= "<hr class='hr' />";
        }

        $body .= "</div><!-- end #list_userpics -->";
        # no default userpic
        $body .= "<p id='no_default_userpic'>";
        $body .= LJ::html_check({ 'name' => 'defaultpic',
                                  'value' => 0,
                                  'type' => 'radio',
                                  'class' => 'radio',
                                  'selected' => $u->{'defaultpicid'} == 0,
                                  'raw' => "id='nodefpic'" });
        $body .= "<label for='nodefpic'>$ML{'.nodefault'}</label></p>";
        $body .= "<?standout" . LJ::html_submit('action:save', $ML{'.btn.save'}) . "standout?>";
        $body .= "</form>";
        $body .= "</div><!-- end #current_userpics -->";
        $body .= "<script type='text/javascript'>\n";
        $body .= "editpicsInit();\n";
        $body .= "</script>\n";

    } elsif (!$fotobilder) {
        $body .= qq {
                <?h1 $ML{'.nopics'} h1?>
                <?p $ML{'.noneupload2'} p?>
            };
    }

    return;
}

_code?><?page
    head=><?_code return $head; _code?>
    title=><?_code return $title; _code?>
    body=><?_code return $body; _code?>
    page?><?_c <LJDEP>
link: htdocs/login.bml, htdocs/allpics.bml
post: htdocs/editpics.bml
    </LJDEP> _c?>
