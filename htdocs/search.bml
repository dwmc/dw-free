<?_c
#
# search.bml
#
# A very basic search function that allows you to search a given journal in
# a few particular cases.
#
# Authors:
#      Mark Smith <mark@dreamwidth.org>
#
# Copyright (c) 2009 by Dreamwidth Studios, LLC.
#
# This program is free software; you may redistribute it and/or modify it under
# the same terms as Perl itself. For a copy of the license, please reference
# 'perldoc perlartistic' or 'perldoc perlgpl'.
#
_c?><?page
body<=
<?_code
{
    use strict;
    use vars qw/ %POST %GET /;
    use Storable;

    # FIXME: english strip and make the UI a lot better :)

    # if no gearman, bail
    my $gc = LJ::gearman_client();
    return "Sorry, content searching is not configured on this server.\n"
        unless $gc && @LJ::SPHINX_SEARCHD;

    # for pages that require authentication
    my $remote = LJ::get_remote();
    return "<?needlogin?>" unless $remote;

    # okay, now let's make sure the data is valid
    my $su = LJ::load_user( $GET{search_user} || $remote->user );
    return "Invalid search user.\n" unless $su;
    return "You can't search that journal!\n"
        unless $remote->equals( $su ) ||
               $su->is_community;

    # and make sure we're searching a paid account
    return "Sorry, searches are only available for paid accounts.\n"
        unless $su->is_paid;

    # for later
    my $sulj = $su->ljuser_display;
    my $suu = $su->user;

    # if they posted we might have to do something
    if ( LJ::did_post() ) {
        return "Failauth.\n" unless LJ::check_form_auth();
        # and make sure we got a query
        my $q = LJ::strip_html( LJ::trim( $POST{query} ) );
        return "Query must be shorter than 255 characters, sorry!\n"
            if length( $q ) > 255;
        return "Please enter a search query.\n"
            unless $q;

        # if an offset, less than 1000 please
        my $offset = $GET{offset} + 0;
        return "Hey, that offset is nonsensical... :(\n"
            if $offset < 0 || $offset > 1000;

        # set a public only flag if this is not your journal
        my $public = ( $remote->equals( $su ) || ( $su->is_community && $remote->member_of( $su ) ) ) ? 0 : 1;

        # the arguments to the search
        my $args = { userid => $su->id, query => $q, offset => $offset, public => $public };
        my $arg = Storable::nfreeze( $args );

        # so we know that they're searching something valid, send to gearman
        my $result;
        my $task = Gearman::Task->new(
            'sphinx_search', \$arg,
            {
                uniq => '-',
                on_complete => sub {
                    my $res = $_[0] or return undef;
                    $result = Storable::thaw( $$res );
                },
            }
        );

        # setup the task set for gearman... really, isn't there a way to make this
        # simpler?  oh well
        my $ts = $gc->new_task_set();
        $ts->add_task( $task );
        $ts->wait( timeout => 20 );

        # if we didn't get a result...
        return "Sorry, we were unable to find a result in the time allotted.  This may mean that ".
               "the server is busy or down.  Please try your query again later.\n"
            unless $result;

        # if we didn't get any matches...
        return "Sorry, we didn't find any matches for the search <strong>$q</strong>.  We looked for $result->{time} seconds, too!\n"
            if $result->{total} <= 0;

        # now we can process the results and do something fascinating!
        my $matches = '';
        foreach my $match ( @{ $result->{matches} } ) {
            my $icon = {
                    public => '',
                    private => "<img src='$LJ::IMGPREFIX/silk/entry/private.png'>",
                    usemask => "<img src='$LJ::IMGPREFIX/silk/entry/filtered.png'>",
                    access => "<img src='$LJ::IMGPREFIX/silk/entry/locked.png'>",
                }->{$match->{security}};

            my $tags = join( ', ', map { "<strong>" . $match->{tags}->{$_} . "</strong>" } keys %{ $match->{tags} } );
            $tags = "<br />Tags: $tags"
                if $tags;

            my $html = qq(<div class='searchres'>$icon <a href="$match->{url}">$match->{subject}</a><br />
                          <span class='exc'>$match->{excerpt}</span>$tags<br />Posted: <strong>$match->{eventtime}</strong><br /><br />
                          </div>);
            $matches .= $html;
        }

        # build the rest of the search page
        my $ret = "<?p You have searched $sulj... p?>" . $matches;

        # put some stats on the output
        my $matchct = scalar( @{ $result->{matches} } );
        my $skip = $offset > 0 ? " (skipped $offset)" : "";
        $ret .= qq(<span class="stats">$matchct results displayed out of $result->{total} hits total$skip for <strong>$q</strong>.
                   $result->{time} seconds.</span>);

        if ( $result->{total} > ( $offset + $matchct ) ) {
            my $offsetm = $offset + $matchct;
            my $fa = LJ::form_auth();
            $ret .= qq(<form method="post" action="$LJ::SITEROOT/search?search_user=$suu&offset=$offsetm">$fa
                       <input type="hidden" name="query" value="$q"> <input type="submit" value="More Results..." />
                       </form>);
        }

        return $ret;
    }

    # give them a form to search...
    my $fa = LJ::form_auth();
    return <<EOF;

<?p Searching $sulj ... p?>

<form method="post" action="$LJ::SITEROOT/search?search_user=$suu">
$fa
<input type="text" name="query" maxlength="255" size="60"> <input type="submit" value="Search!" />
</form>

<?p This is a beta search.  Things may be slow or broken while we iron out the kinks
in the system.  If you run into trouble, let us know! p?>

EOF
}
_code?>
<=body
title=>Content Search
head<=
<style type="text/css">
.exc { padding-left: 1em; font-style: italic; font-size: smaller; }
.stats { font-style: italic;  }
.searchres { margin: 0.2em 0em 0.2em 2em; }
</style>
<=head
page?>
