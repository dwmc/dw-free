<?page
title=><?_ml .title _ml?>
body<=
<?_code
{
    use strict;
    use vars qw(%GET %POST);

    LJ::set_active_crumb('commmembers');

    return LJ::server_down_html() if $LJ::SERVER_DOWN;

    my $ret;

    # get remote
    my $remote = LJ::get_remote();
    unless ($remote) {
        $ret .= "<?needlogin?>";
        return $ret;
    }

    # old GET arg
    if ($GET{comm}) {
        return BML::redirect("$LJ::SITEROOT/community/members.bml?authas=$GET{comm}");
    }

    my $cname = $GET{authas};
    return BML::redirect("$LJ::SITEROOT/community/manage.bml") unless $cname;

    $ret .= "<form action='members.bml' method='GET'>\n";
    $ret .= LJ::make_authas_select($remote, { authas => $GET{authas}, type => 'C' });
    $ret .= "</form>\n\n";

    # get $c object
    my $c = LJ::load_user($cname);
    unless ($c) {
        $ret .= "<?h1 $ML{'Error'} h1?><?p $ML{'.error.nocomm'} p?>";
        return $ret;
    }

    # make sure it is a comm
    unless ( $c->is_comm ) {
        $ret .= "<?h1 $ML{'Error'} h1?><?p ";
        $ret .= BML::ml( '.error.notcomm', { user => LJ::ljuser($c) } );
        $ret .= " p?>";
        return $ret;
    }

    my $cid = $c->{'userid'};
    # is $remote an admin?
    unless (LJ::can_manage_other($remote, $c)) {
        $ret .= "<?h1 $ML{'Error'} h1?><?p ";
        $ret .= BML::ml( '.error.noaccess',
                        { comm => LJ::ljuser( $cname, { type => 'C' } ) } );
        $ret .= " p?>";
        return $ret;
    }

    $ret .= LJ::maintainer_linkbar($c, "members");

    my @allattribs = ('member', 'post', 'preapprove', 'moderate', 'admin');
    my %attrshort = ( X => 'member', P => 'post', N => 'preapprove', M => 'moderate', A => 'admin');
    my %attrshort_r = ( map { $attrshort{$_} => $_ } keys %attrshort ); # reversed

    # saving a form submission
    if ($POST{'action:update'}) {
        # validate form auth
        return "<?h1 $ML{'Error'} h1?><?p $ML{'error.invalidform'} p?>"
            unless LJ::check_form_auth();

        my @userids = split(',', $POST{'ids'});
        my @saveattribs = split(',', $POST{'attribs'});

        # now we need to create our 'was' list
        my %was; # ( userid => { attrib => 1; } )
        my %users; # ( userid => username )
        foreach my $row (split ';', $POST{was}) { # UID:UNAME:MNPX;UID:UNAME:MX;UID:UNAME:AM
            # if this row matches...
            if ($row =~ /^(\d+):(\w+):(\w+)$/) {
                my ($uid, $name, $attrs) = ($1, $2, $3);
                $uid += 0;
                next unless $uid && $name && $attrs;

                # split attrs and setup
                $was{$uid}->{$attrshort{$_}} = 1 foreach split '', $attrs;
                $users{$uid} = $name;
            }
        }

        # invite new users
        my @to_add;
        my @add_errors;
        foreach my $num (1..5) {
            my $given_user = LJ::ehtml(LJ::trim($POST{"add_$num"}));

            next unless $given_user;

            my $target = LJ::load_user($given_user);
            unless ($target) {
                push @add_errors, BML::ml( '.error.nouser',
                                           { user => $given_user } );
                next;
            }

            my $target_disp = LJ::ljuser($target);

            unless ( $target->is_visible ) {
                push @add_errors, BML::ml( '.error.notactive',
                                           { user => $target_disp } );
                next;
            }

            my @attr = grep { defined $POST{"add_${num}_$_"} } @saveattribs;
            unless (@attr) {
                push @add_errors, BML::ml( '.error.noattr',
                                           { user => $target_disp,
                                             type => $target->{'journaltype'} } );
                next;
            }

            unless ( $target->is_person ) {
                push @add_errors, BML::ml( '.error.invaliduser',
                                           { user => $target_disp,
                                             type => $target->{'journaltype'} } );
                next;
            }

            if (grep { $target->{'userid'} == $_ } @userids) {
                push @add_errors, BML::ml( '.error.alreadyadded',
                                           { user => $target_disp,
                                             type => $target->{'journaltype'} } );
                next;
            }

            my $adult_content;
            unless ($target->can_join_adult_comm( comm => $c, adultref => \$adult_content )) {
                if ( $adult_content eq "explicit" ) {
                    push @add_errors, BML::ml( '.error.isminor',
                                               { user => $target_disp } );

                    next;
                }
            }

            # insert authactions row
            push @to_add, [ $target, \@attr ];
        }
        return LJ::bad_input(@add_errors) if @add_errors;

        # now do the additions if any were needed
        my @fail;
        my @invited;
        if (@to_add) {
            foreach my $row (@to_add) {
                # good, let's extend an invite to this person
                my ($target, $attrs) = @$row;
                if (LJ::send_comm_invite($target, $c, $remote, $attrs)) {
                    push @invited, $row;
                } else {
                    push @fail, [ $target, LJ::last_error_code() ];
                }
            }
        }
        if (@fail) {
            my @bad;
            foreach (@fail) {
                if ($_->[1] eq 'comm_user_has_banned') {
                    push @bad, BML::ml( '.error.adding', { user => LJ::ljuser( $_->[0] ) } );
                } elsif ($_->[1] eq 'comm_invite_limit') {
                    push @bad, BML::ml( '.error.limit', { user => LJ::ljuser( $_->[0] ) } );
                } else {
                    push @bad, BML::ml( '.error.unknown', { user => LJ::ljuser( $_->[0] ) } );
                }
            }
            return LJ::bad_input(@bad);
        }

        # initialize lists of users to update and delete
        # keyed on attribute type
        my %add = ();
        my %delete = ();
        foreach (@allattribs) {
            $add{$_} = {};
            $delete{$_} = {};
        }

        # need a db handle now
        my $dbh = LJ::get_db_writer();

        # if we have $other_maints, then there are maintainers not in our
        # current view, so they will not be modified, so the user can delete
        # all maintainers from the current view
        my $in = join(',', map { $dbh->quote($_) } @userids);
        my $other_maints = $dbh->selectrow_array("SELECT COUNT(*) FROM reluser " .
                                                 "WHERE userid=? AND type='A' " .
                                                 "AND targetid NOT IN ($in)",
                                                 undef, $cid);

        # users already in community
        my $maints = 0;
        my $us = LJ::load_userids(@userids);
        my (%addr, %delr); # store additions and removals sorted by userid
        foreach my $id (@userids) {
            $id = $id + 0;
            my $str;
            foreach (@allattribs) {
                if ($POST{"edit_${id}_$_"}) {
                    unless ($was{$id}->{$_}) {
                        $add{$_}->{$id} = 1;
                        $addr{$id}->{$_} = 1;
                    }
                } else {
                    if ($was{$id}->{$_}) {
                        $delete{$_}->{$id} = 1;
                        $delr{$id}->{$_} = 1;
                    }
                }
            }
            $maints++ if $POST{"edit_${id}_admin"} && !$us->{$id}->is_expunged;
        }

        # can't remove ALL maintainers, give them an error so they can
        # go back and decide who to keep
        if (! $other_maints && $maints < 1) {
            $ret .= "<?h1 $ML{'Error'} h1?><?p ";
            $ret .= BML::ml( '.error.nomaint',
                {
                    comm  => LJ::ljuser( $cname, { 'type' => 'C' } ),
                    aopts => "href='" . BML::get_uri() . "?authas=$cname'",
                } );
            $ret .= " p?>";
            return $ret;
        }

        # delete members
        foreach my $uid ( keys %{ $delete{member} || {} } ) {
            my $temp_u = LJ::load_userid( $uid )
                or next;
            $temp_u->remove_edge( $cid, member => {} );
        }

        # create a closure to send a notification email to a user if they are
        # added or removed from being a maintainer
        my $sendmail = sub {
            my ($targetu, $html, $plain, $subject) = @_;
            return unless $targetu;

            my $fromname = $remote->{user};

            #todo: check if user wants to receive emails?
            if ($targetu->email_raw) {
                  # send an email to this user:
                  # send an email with both plain and html content
                  my $msg =  new MIME::Lite (
                                             'From'    => "\"$LJ::SITENAME\" <$LJ::BOGUS_EMAIL>",
                                             'To'      => $targetu->email_raw,
                                             'Subject' => $subject,
                                             'Type'    => 'multipart/alternative',
                                             );

                  my $encoding = $targetu->{'mailencoding'} ?
                      $LJ::CACHE_ENCODINGS{$targetu->{'mailencoding'}} :
                      "UTF-8";

                  # add the plaintext version
                  my $plainpart = $msg->attach(
                                               'Type'     => 'TEXT',
                                               'Data'     => $plain,
                                               'Encoding' => 'quoted-printable',
                                               );

                  $plainpart->attr("content-type.charset" => $encoding)
                      if $LJ::UNICODE;

                  # add the html version
                  my $htmlpart = $msg->attach(
                                              'Type'     => 'text/html',
                                              'Data'     => $html,
                                              'Encoding' => 'quoted-printable'
                                              );

                  $htmlpart->attr("content-type.charset" => $encoding)
                      if $LJ::UNICODE;

                  LJ::send_mail($msg);
            }
        };

        # get all the maintainers who were removed
        my $changedmaintainers = LJ::load_userids(keys %{$delete{admin}}, keys %{$add{admin}});

        foreach my $uid (keys %{$delete{admin} || {}}) {
            # log maintainer deletions
            $c->log_event('maintainer_remove', { actiontarget => $uid, remote => $remote });

            my $delmaintu = $changedmaintainers->{$uid};
            next unless $delmaintu;

            # send email to the poor maintainer who got removed
            my $mailusername = $delmaintu->{user};
            my $mailusercname = $c->{name};
            my $mailclink = LJ::journal_base($c, ['community']);

            my $html;

            $html .= "<p>";
            $html .= BML::ml( '.email.hello', { site => $LJ::SITENAMESHORT, user => $mailusername } );
            $html .= "</p>\n<p>";
            $html .= BML::ml( '.email.del.body', { admin => $remote->{user}, comm => qq(<a href="$mailclink">$mailusercname</a>) } );
            $html .= "</p>\n<p>$ML{'.email.close'}<br/>\n";
            $html .= BML::ml( '.email.signed', { site => $LJ::SITENAME } );
            $html .= "<br/>$LJ::SITEROOT</p>";

            my $plain;

            $plain .= BML::ml( '.email.hello', { site => $LJ::SITENAMESHORT, user => $mailusername } );
            $plain .= "\n\n";
            $plain .= BML::ml( '.email.del.body', { admin => $remote->{user}, comm => $mailusercname } );
            $plain .= "\n\n$ML{'.email.close'}\n";
            $plain .= BML::ml( '.email.signed', { site => $LJ::SITENAME } );
            $plain .= "\n$LJ::SITEROOT\n";

            my $subject = BML::ml( '.email.del.subject', { comm => $mailusercname } );
            $sendmail->($delmaintu, $html, $plain, $subject);
        }

        # delete other rel edges
        LJ::clear_rel_multi(
                            (map { [$cid, $_, 'A'] } keys %{$delete{admin}      || {}}),
                            (map { [$cid, $_, 'P'] } keys %{$delete{post}       || {}}),
                            (map { [$cid, $_, 'M'] } keys %{$delete{moderate}   || {}}),
                            (map { [$cid, $_, 'N'] } keys %{$delete{preapprove} || {}}),
                            );

        # perform additions
        my @msgs;
        if (%{$add{'member'}}) {
            foreach my $id (keys %{$add{'member'}}) {
                next if $was{$id}->{'member'};
                my $u = LJ::load_userid($id);
                if (LJ::u_equals($u, $remote)) {
                    # you're allowed to add yourself as member
                    LJ::join_community($remote, $c);
                } else {
                    if (LJ::send_comm_invite($u, $c, $remote, [ 'member' ])) {
                        # if it succeeded, push the reinvited information
                        push @msgs, BML::ml('.reinvited2',
                            { user => LJ::ljuser($u),
                              aopts => "href='$LJ::SITEROOT/manage/invites.bml'" });
                    }
                }
            }
        }

        foreach my $uid (keys %{$add{admin} || {}}) {
            # log maintainer additions
            $c->log_event('maintainer_add', { actiontarget => $uid, remote => $remote });

            my $newmaintu = $changedmaintainers->{$uid};
            next unless $newmaintu;

            # send email to the new maintainer
            my $mailusername = $newmaintu->{user};
            my $mailusercname = $c->{name};
            my $mailclink = LJ::journal_base($c, ['community']);
            my $mailcommanlink = "$LJ::SITEROOT/community/manage.bml";

            my $html;

            $html .= "<p>";
            $html .= BML::ml( '.email.hello', { site => $LJ::SITENAMESHORT, user => $mailusername } );
            $html .= "</p>\n<p>";
            $html .= BML::ml( '.email.add.body1', { comm => qq(<a href="$mailclink">$mailusercname</a>) } );
            $html .= "</p>\n<p>";
            $html .= BML::ml( '.email.add.body2.html', { aopts => "href='" . $mailcommanlink . "'" } );
            $html .= "</p>\n<p>$ML{'.email.close'}<br/>\n";
            $html .= BML::ml( '.email.signed', { site => $LJ::SITENAME } );
            $html .= "<br/>$LJ::SITEROOT</p>";

            my $plain;

            $plain .= BML::ml( '.email.hello', { site => $LJ::SITENAMESHORT, user => $mailusername } );
            $plain .= "\n\n";
            $plain .= BML::ml( '.email.add.body1', { comm => $mailusercname } );
            $plain .= "\n\n$ML{'.email.add.body2.plain'}\n\n$mailcommanlink";
            $plain .= "\n\n$ML{'.email.close'}\n";
            $plain .= BML::ml( '.email.signed', { site => $LJ::SITENAME } );
            $plain .= "\n$LJ::SITEROOT\n";

            my $subject = BML::ml( '.email.add.subject', { comm => $mailusercname } );
            $sendmail->($newmaintu, $html, $plain, $subject);
        }

        # set rels in db/memcache
        LJ::set_rel_multi( (map { [$cid, $_, 'A'] } keys %{$add{admin}      || {}}),
                           (map { [$cid, $_, 'P'] } keys %{$add{post}       || {}}),
                           (map { [$cid, $_, 'M'] } keys %{$add{moderate}   || {}}),
                           (map { [$cid, $_, 'N'] } keys %{$add{preapprove} || {}}),
                           );

        # delete reluser memcache key
        LJ::MemCache::delete([ $cid, "reluser:$cid:A" ]);
        LJ::MemCache::delete([ $cid, "reluser:$cid:P" ]);
        LJ::MemCache::delete([ $cid, "reluser:$cid:M" ]);
        LJ::MemCache::delete([ $cid, "reluser:$cid:N" ]);

        # create some other messages
        my %done; # keep track of who we've done
        foreach my $id (keys %addr, keys %delr) {
            next if $done{$id}++;

            my ($str, @astr, @dstr);
            push @astr, $ML{"/manage/invites.bml.label.$_"}
                foreach keys %{$addr{$id} || {}};
            push @dstr, $ML{"/manage/invites.bml.label.$_"}
                foreach keys %{$delr{$id} || {}};
            $str .= "<li>" . BML::ml('.success.added', { list => join(', ', @astr) }) . "</li>\n" if @astr;
            $str .= "<li>" . BML::ml('.success.deleted', { list => join(', ', @dstr) }) . "</li>\n" if @dstr;
            push @msgs, LJ::ljuser($users{$id}) . ":<ul>$str</ul>" if $str;
        }

        if (@invited) {
            $ret .= "<?p ";
            $ret .= BML::ml('.success.invited2',
                            { aopts => "href='$LJ::SITEROOT/manage/invites.bml'" });
            $ret .= " p?><ul>";
            foreach my $row (@invited) {
                $ret .= "<li>" . LJ::ljuser($row->[0]) . ": ";
                $ret .= "$ML{\"/manage/invites.bml.label.$_\"}, " foreach @{$row->[1] || []};
                chop $ret; chop $ret;
                $ret .= "</li>\n";
            }
            $ret .= "</ul>";
        }
        $ret .= "<?p $ML{'.success.nochanges'} p?>" unless @msgs || @invited;
        $ret .= "<?p " . BML::ml( '.success.return2', { aopts => "href='" . BML::get_uri() . "?authas=$cname'" } ) . " p?>";

        return $ret;

    }

    # browsing mode

    # now get lists of: members, admins, able to post, moderators
    my %users = ();

    # need a dbr now
    my $dbr = LJ::get_db_reader();

    # get all community edges
    # FIXME: kind of lame to do it this way, manually, instead of having accessors for this...
    my $sth = $dbr->prepare("SELECT r.targetid, r.type, u.user FROM reluser r, useridmap u " .
                            "WHERE r.targetid = u.userid AND r.userid=? AND r.type IN ('A','P','M','N','E')");
    $sth->execute($cid);

    my %count;
    while (my ($id, $type, $user) = $sth->fetchrow_array) {
        $users{$id}->{'userid'} = $id;
        $users{$id}->{'name'} = $user;
        my $key = {'A'=>'admin','P'=>'post','M'=>'moderate','N'=>'preapprove','E'=>'member'}->{$type};
        $users{$id}->{$key} = 1;
        $count{$type}++;
    }

    # columns of our table, excluding username
    my @attribs = ('member', 'post');
    LJ::load_user_props($c, 'moderated');
    push @attribs, ('preapprove')
        if $c->{'moderated'} || $count{'N'};
    push @attribs, ('moderate')
        if $c->{'moderated'} || $count{'M'};
    push @attribs, 'admin';

    # sorting method;
    my $method = $GET{'sort'};

    my $cmp = sub {$a->{'name'} cmp $b->{'name'}};
    $cmp = sub {$b->{'member'} <=> $a->{'member'}} if $method eq 'member';
    $cmp = sub {$b->{'admin'} <=> $a->{'admin'}} if $method eq 'admin';
    $cmp = sub {$b->{'post'} <=> $a->{'post'}} if $method eq 'post';
    $cmp = sub {$b->{'moderate'} <=> $a->{'moderate'}} if $method eq 'moderate';
    $cmp = sub {$b->{'preapprove'} <=> $a->{'preapprove'}} if $method eq 'preapprove';

    my @users = sort $cmp values %users;
    my $page_size = 100; # change to adjust page size

    # are we going to jump to a specific user ?
    my $jumppage;
    my $jumpuser;
    if (@users > $page_size && $POST{'jumpto'} =~ /^\w+$/) {
        my $ct;
        foreach (@users) {
            $jumppage++ if $ct % $page_size == 0;
            if ($POST{'jumpto'} eq $_->{'name'}) {
                $jumpuser = $_->{'name'};
                last;
            }
            $ct++;
        }
        undef $jumppage unless $jumpuser;
    }

    # how to make links back to this page
    my $self_link = sub {
        my $sort = "&sort=$GET{'sort'}" if $GET{'sort'};
        return "members.bml?authas=$cname&page=$_[0]$sort";
    };

    my %items = BML::paging(\@users, $jumppage || $GET{'page'}, $page_size);
    my $navbar = LJ::paging_bar($items{'page'}, $items{'pages'},
                                 { 'self_link' => $self_link });
    @users = @{$items{'items'}};

    # output starts here
    $ret .= BML::ml('.intro', { aopts1 => "href='$LJ::HELPURL{maintainership}'", aopts2 => "href='$LJ::HELPURL{add_to_comm}'" }) . "<br /><br />";
    $ret .= $ML{'.intro.invite'};

    $ret .= "<form method='post' action='members.bml?authas=$cname'>";
    $ret .= LJ::form_auth();

    # jump to user
    if ($items{'pages'} > 1) {
        $ret .= "<div style='margin-left: 30px;'>$ML{'.jump'}: ";
        $ret .= LJ::html_text({ 'name' => 'jumpto', 'value' => $POST{'jumpto'},
                                'class' => 'text', 'size' => '10', 'maxlength' => '25' }) . " ";
        $ret .= LJ::html_submit(undef, 'Go') . "</div>";

        $ret .= $navbar;
    }

    my $sortlink = BML::get_uri() . "?authas=$cname&sort=";
    $ret .= "<br /><div align='center'><table class='alternating-rows' cellpadding='0' cellspacing='0'>\n<tr>" .
            "<th><a href='${sortlink}name'>$ML{'.key.user'}</a></th>";
    $ret .= "<th><a href='${sortlink}$_'>".$ML{".key.$_"}."</a></th>" for (@attribs);
    $ret .= "</tr>\n";

    # rows for existing users
    my $rc = 0;
    my @wstrs;
    foreach(@users) {
        my $rstyle = ($rc++ & 1) ? "altrow2" : "altrow1";
        $ret .= "<tr class='$rstyle'><td>" . LJ::ljuser($_->{'name'}) . "</td>";
        my $wstr;
        foreach my $key (@attribs) {
            $ret .= "<td style='text-align: center;'>";
            $ret .= LJ::html_check({ 'name' => "edit_$_->{'userid'}_$key",
                                     'selected' => $_->{$key} });
            $wstr .= $attrshort_r{$key} if $_->{$key};
            $ret .= "</td>";
        }
        push @wstrs, "$_->{userid}:$_->{name}:$wstr" if $wstr;
        $ret .= "</tr>\n";
    }

    # if on the last page, let users add to the list
    if ($items{'page'} == $items{'pages'}) {
        foreach(1..5) {
            my $rstyle = ($rc++ & 1) ? "altrow2" : "altrow1";
            $ret .= "<tr class='$rstyle'><td>";
            $ret .= LJ::html_text({ 'name' => "add_$_", 'size' => '10', 'class' => 'text', 'maxlength' => '25' }) . "</td>";
            foreach my $key (@attribs) {
                $ret .= "<td style='text-align: center;'>";
                if ($key eq 'member' || $key eq 'post') {
                    $ret .= LJ::html_check({ name => "add_${_}_$key", selected => 1, });
                } else {
                    $ret .= LJ::html_check({ name => "add_${_}_$key" });
                }
                $ret .= "</td>";
            }
            $ret .= "</tr>\n";
        }
    }

    # some hidden values
    $ret .= "</table>";
    $ret .= LJ::html_hidden('ids', join(',', map { $_->{'userid'}} @users),
                            'attribs', join(',', @attribs),
                            'was', join(';', @wstrs)) . "\n";

    $ret .= "<p>" . LJ::html_submit('action:update', $ML{'.update'}) . "</p>\n";
    $ret .= "</div></form>\n\n";

    $ret .= $navbar;

    return $ret;

}
_code?>

<=body
page?>
