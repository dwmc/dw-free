<?page
body<=
<?_code
{
    use strict;
    use vars qw (%POST %GET $body $title $headextra);
    use Carp qw(croak);

    $title = BML::ml('.title');

    use Class::Autouse qw(LJ::NotificationMethod LJ::Event);

    my @errors;

    my $remote = LJ::get_remote();
    return "<?needlogin?>" unless $remote;

    if ($remote->is_in_beta('settings2008')) {
        return BML::redirect("$LJ::SITEROOT/manage/settings/index2.bml?cat=notifications");
    }

    return "Not ready" unless $remote->can_use_esn;

    my $formauth = LJ::form_auth();

    my $my_account_extra = LJ::run_hook('subscriptions_manage_my_account_extra', $remote);

    # set up default subscriptions for users that have not managed ESN stuff
    # do this for remote only, not authas users
    if (! $remote->prop('esn_has_managed') && ! $remote->subscription_count) {
        $remote->set_prop('esn_has_managed', 1);

        my @default_subscriptions = (
                                     LJ::Subscription::Pending->new($remote,
                                                                    event     => 'OfficialPost',
                                                                    ),
                                     );

                                     push @default_subscriptions, $my_account_extra
                                        if $my_account_extra;

                                     if ($remote->prop('opt_gettalkemail') ne 'N') {
                                         push @default_subscriptions, (
                                                                       LJ::Subscription::Pending->new($remote,
                                                                                                      event     => 'JournalNewComment',
                                                                                                      journal   => $remote,
                                                                                                      method    => 'Inbox',
                                                                                                      ),

                                                                       LJ::Subscription::Pending->new($remote,
                                                                                                      event     => 'JournalNewComment',
                                                                                                      journal   => $remote,
                                                                                                      method    => 'Email',
                                                                                                      ),
                                                                       );
                                     }

        $_->commit foreach @default_subscriptions;
    }

    # handle input
    if (LJ::did_post()) {
        return LJ::error_list(BML::ml('error.invalidform')) unless LJ::check_form_auth();

        # do they want to add or edit subscriptions?
        next unless $POST{mode} eq 'save_subscriptions';

        my @sub_edit;
        my @to_consider;
        my @to_activate;

        foreach my $postkey (keys %POST) {
            my $subscr;
            my $old_postkey = $postkey;
            my $old = $postkey =~ /-old$/;

            # are there other options for this pending subscription? if so, process those not this one
            next if $postkey =~ /\.arg\d/;

            $subscr = LJ::Subscription->thaw($postkey, $remote, \%POST) or next;

            if ($subscr->pending) {
                push @to_consider, $subscr;
            } else {
                push @to_activate, $subscr if !$old && !$subscr->active;
            }

            # remove old string
            $postkey =~ s/-old// if $old;

            next unless $old;

            my $oldvalue = $POST{$old_postkey};
            my $checked = $POST{$postkey};

            push @sub_edit, [
                             $subscr,
                             $checked,
                             $oldvalue,
                             ];
        }

        # first process deletions
        foreach my $edit_info (@sub_edit) {
            my ($subscr, $checked, $oldvalue) = @$edit_info;

            if (!$checked && $oldvalue && $subscr->method->configured_for_user($remote)) {
                # if it's not checked and is currently a real subscription, deactivate it
                # unless we disabled it for them (disabled checkboxes don't POST)
                $subscr->deactivate;
            }
        }

        # then process new subs and activations
        foreach my $subscr (@to_activate) {
            my @inbox_subs = grep { $_->active && $_->enabled } $remote->find_subscriptions(method => 'Inbox');

            if ((scalar @inbox_subs) >= $remote->max_subscriptions) {
                # too many, sorry
                push @errors, LJ::errobj("Subscription::TooMany", subscr => $subscr, u => $remote);
            } else {
                # all is good, reactivate it
                $subscr->activate;
            }
        }

        # Define limits
        my $paid_max = LJ::get_cap('paid', 'subscriptions');        
        my $remote_max  = $remote->max_subscriptions;
        # max for total number of subscriptions (generally it is $paid_max) 
        my $system_max  = $remote_max > $paid_max ? $remote_max : $paid_max;

        my $inbox_ntypeid = LJ::NotificationMethod::Inbox->ntypeid;
        my @other_ntypeid_to_consider;

        # process new inbox subs
        foreach my $subscr (@to_consider) {
            # if this is not an inbox sub, check it
            if ($subscr->ntypeid != $inbox_ntypeid) {
                push @other_ntypeid_to_consider, $subscr;
            } else {
                # this is an inbox subscription, save it
                my @all_subs = $remote->find_subscriptions(method => 'Inbox');
                my @active_subs = grep { $_->active && $_->enabled } @all_subs;

                if (@active_subs >= $remote_max) {
                    push @errors, LJ::errobj("Subscription::TooMany", subscr => $subscr, u => $remote);
                } elsif (@all_subs >= $system_max) {
                    push @errors, LJ::errobj("Subscription::TooManySystemMax", subscr => $subscr, u => $remote, max => $system_max);
                } else {
                    # save this for consideration after we've processed all inbox subscriptions first
                    $subscr->commit;
                }
            }
        }

        # process all other new subs
        foreach my $subscr (@other_ntypeid_to_consider) {
            my %inbox_sub_params = $subscr->sub_info;
            # don't save a subscription if there is no corresponding inbox sub for it
            $inbox_sub_params{ntypeid} = $inbox_ntypeid;
            delete $inbox_sub_params{flags};

            my ($inbox_sub) = $remote->has_subscription(%inbox_sub_params);

            # If Inbox is always on, then act like an Inbox sub exists
            my $always_checked = $subscr->event_class->always_checked ? 1 : 0;
            next if (!$always_checked && !($inbox_sub && $inbox_sub->active && $inbox_sub->enabled));

            my @all_subs = $remote->find_subscriptions(method => $subscr->method);
            my @active_subs = grep { $_->active && $_->enabled } @all_subs;

            if (@active_subs >= $remote_max) {
                push @errors, LJ::errobj("Subscription::TooMany", subscr => $subscr, u => $remote);
                next;
            } elsif (@all_subs >= $system_max) {
                push @errors, LJ::errobj("Subscription::TooManySystemMax", subscr => $subscr, u => $remote, max => $system_max);
                next;
            }

            $subscr->commit;
        }

        delete $remote->{_subscriptions};
    }

    # look for deletions from GET
    foreach my $subscr ($remote->subscriptions) {
        my $id = $subscr->id;
        next unless $id;

        if ($GET{"deletesub_$id"}) {
            $subscr->delete;
        }
    }

    $body .= "<?p" . LJ::error_list(@errors) . "p?>" if scalar @errors;

    return BML::redirect($POST{ret_url}) if $POST{ret_url} && ! (scalar @errors);

    ###################### Print subscribe table
    my @categories = (
                      {
                          "My Account" => [
                                           LJ::Subscription::Pending->new($remote,
                                                                          event     => 'OfficialPost',
                                                                          ),
                                           LJ::Subscription::Pending->new($remote,
                                                                          event     => 'JournalNewComment',
                                                                          journal   => $remote,
                                                                          ),
                                           LJ::Subscription::Pending->new($remote,
                                                                          event     => 'PollVote',
                                                                          journal   => $remote,
                                                                          ),

                                           'Befriended',
                                           'Defriended',
                                           LJ::Subscription::Pending->new($remote,
                                                                          event     => 'UserMessageRecvd',
                                                                          journal   => $remote,
                                                                          default_selected => 1,
                                                                          ),
                                           ],
                          },
                      {
                          "Friends and Communities" => [
                                                        'InvitedFriendJoins',
                                                        'CommunityInvite',
                                                        'CommunityJoinRequest',
                                                        LJ::Subscription::Pending->new(
                                                                                       $remote,
                                                                                       event => 'NewUserpic',
                                                                                       ),
                                                        LJ::Subscription::Pending->new(
                                                                                       $remote,
                                                                                       event => 'Birthday',
                                                                                       ),
                                                        (LJ::run_hook('subscriptions_manage_friend_pending_extra', $remote) || ()),
                                                        ],
                          },
                      );

    unshift @{$categories[0]->{'My Account'}}, $my_account_extra
        if $my_account_extra;

    $body .= qq {
        <div class="Blurb">$ML{'.subtitle'}</div>
    };

    $body .= LJ::subscribe_interface($remote,
                                     journal      => $remote,
                                     categories   => \@categories,
                                     formauth     => $formauth,
                                     showtracking => 1,
                                     );

    return $body;
}
_code?>
<=body
title=><?_code return $title; _code?>
head<=
<?_code return $headextra; _code?>
<=head
<=body
page?>
