<?_c
# This code was forked from the LiveJournal project owned and operated
# by Live Journal, Inc. The code has been modified and expanded by
# Dreamwidth Studios, LLC. These files were originally licensed under
# the terms of the license supplied by Live Journal, Inc, which can
# currently be found at:
#
# http://code.livejournal.org/trac/livejournal/browser/trunk/LICENSE-LiveJournal.txt
#
# In accordance with the original license, this code and all its
# modifications are provided under the GNU General Public License.
# A copy of that license can be found in the LICENSE file included as
# part of this distribution.
_c?>
<?page
body<=
<?_code
{
    use strict;
    use LJ::Directory::Search;
    use LJ::Widget;
    use vars qw(%GET %POST %FORM $title $headextra @errors @warnings);

    $title = $ML{'.title'};

    # redirect to directorysearch if we haven't submitted the form
    return BML::redirect( "/directorysearch" )
        unless $GET{opt_pagesize} || $GET{s_loc} || $GET{s_fro};

    LJ::need_res(qw(
                    stc/directory.css
                    ));

    LJ::set_active_crumb('advsearch');

    my $remote = LJ::get_remote();
    return "<?needlogin?>" unless $remote;

    return LJ::CProd->inline($remote, inline => 'Directory') || BML::ml('cprod.directory.text3.v1')
        unless $remote->can_use_directory;

    my $ret = '';

    if (! $GET{start_search}) {
        # do a refresh to the page with the finished results.
        # this will display some nice text to the user while they wait
        # for their results.

        my $refurl = LJ::ehtml( LJ::page_change_getargs( start_search => 1 ) );
        $headextra = "<meta http-equiv='Refresh' content='1;URL=$refurl' id='refresher' />";

        my $dots = LJ::img( 'searchdots', '' );
        $ret .= qq {
            <div id="SearchWaitText" style='text-align: center;'>
               <b>$ML{'.search.title'}$dots</b>
               <p>$ML{'.search.monkey'}</p>
            </div>
        };

        return $ret;
    }

    # Do the actual search

    my $url = "$LJ::SITEROOT/";
    $url .= $GET{journaltype} && $GET{journaltype} eq "C" ? "community/search"
                                                          : "directorysearch";
    $ret .= qq {
        <div id="NewSearch">
            <a href="$url"><< $ML{'.new_search'}</a>
        </div>
    };

    $ret .= qq {
        <?h1 $ML{'.search_results'} h1?>
    };

    my $filter_url = LJ::ehtml( LJ::page_change_getargs( start_search => 1,
                                                         journaltype => '',
                                                         page => '' ) );

    my $all_search = "$ML{'.new_all_search'}";
    $all_search = "<a href='$filter_url'>$all_search</a>"
        if uc( $GET{journaltype} ) =~ /^[CPI]$/;

    my $community_search = "$ML{'.new_community_search'}";
    $community_search = "<a href='$filter_url&journaltype=C'>$community_search</a>"
        unless uc( $GET{journaltype} ) eq 'C';

    my $user_search = "$ML{'.new_user_search'}";
    $user_search = "<a href='$filter_url&journaltype=P'>$user_search</a>"
        unless uc( $GET{journaltype} ) eq 'P';

    my $identity_search = "$ML{ '.new_identity_search' }";
    $identity_search = "<a href='$filter_url&journaltype=I'>$identity_search</a>"
        unless uc( $GET{journaltype} ) eq 'I';

    $ret .= qq {\n<div id="FilterSearch">$ML{'.new_search_show'}&nbsp;$all_search&nbsp;|&nbsp;};
    $ret .= qq {$community_search&nbsp;|&nbsp;$user_search&nbsp;|&nbsp;$identity_search</div>\n};

    if (LJ::Hooks::run_hook("interest_search_ignore", query => $GET{int_like})) {
        $ret .= $ML{'.unable_find_users'};
        return $ret;
    }

    my $page = delete $GET{page} || 1;
    my $page_size = $GET{opt_pagesize};

    # country, state and city fields are generated by LJ::Widget::GeoSearchLocation widget,
    # hence all corresponding <input>-tags have widget-specific prefixed 'name' attribute
    # calling post_fields to fix this
    my $widget_params = LJ::Widget::GeoSearchLocation->post_fields(\%GET);
    $GET{'loc_cn'} ||= $widget_params->{'country'};
    $GET{'loc_st'} ||= $widget_params->{'statedrop'} || $widget_params->{'stateother'};
    $GET{'loc_ci'} ||= $widget_params->{'city'};

    # parse GET args into search constraints
    my @constraints = LJ::Directory::Constraint->constraints_from_formargs(\%GET);

    # do synchronous search
    my $dir = LJ::Directory::Search->new(page_size => $page_size, page => $page,
                                         format => $GET{opt_format}, constraints => \@constraints);
    my LJ::Directory::Results $res = $dir->search;
    $res = $dir->search while !$res;

    unless ($res) {
        $ret .= "<?errorbar $ML{'.errar.search_dir'} errorbar?>";
        return $ret;
    }

    my $pagecount = $res->pages;
    my @users     = $res->users;

    unless (@users) {
        $ret .= "<div class='warning-box'>$ML{'.no_results'}</div>";
        return $ret;
    }

    my $querystring = join('&', map { LJ::eurl($_) . '=' . LJ::eurl($GET{$_}) } grep { $_ ne 'start_search' } keys %GET);

    my $pagingbar = LJ::paging_bar($page, $pagecount, {
        self_link => sub { BML::get_uri() . "?page=$_[0]&" . $querystring },
    });

    $ret .= $pagingbar;
    $ret .= $res->render;

    # if more than 20 results (or 4 rows), show paging bar again at bottom
    $ret .= $pagingbar if @users > 20;

    return $ret;
}
_code?>
<=body
title=><?_code return $title; _code?>
head<=
<?_code return $headextra; _code?>
<=head
<=body
page?>
